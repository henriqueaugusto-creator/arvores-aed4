#include <stdio.h>
#include <stdlib.h>

typedef enum { VERMELHO, PRETO} Cor;

typedef struct No{
  int chave;
  Cor cor;
  struct No *pai;
  struct No *esquerda;
  struct No* direita;
} No;

// Estrutura da Árvore Rubro-Negra
typedef struct ArvoreRubroNegra {
// Nó *raiz é o no que sempre aponta para o topo o valor da raiz
    No *raiz;
// Nó *NIL ele é um no tambem chamado de sentinela serve principalmente para simplificar o codigo
// o nó NIL substitui a verificação se o ponteiro é NULL e facilita o balanceamento
// sempre tera a cor PRETO e todo os nós folhas aponta para ele
    No *NIL;
} ArvoreRubroNegra;

// Função para fazer a criação da Arvore Rubro Negra
ArvoreRubroNegra* criar_arvore() {
// Realiza a alocação de memoria para o ponteiro T
    ArvoreRubroNegra* T = (ArvoreRubroNegra*)malloc(sizeof(ArvoreRubroNegra));
// Realiza a alocação de memoria para o ponteiro T->NIL
    T->NIL = (No*)malloc(sizeof(No));
// Inicializa na cor PRETO
    T->NIL->cor = PRETO;
// Inicializa com o valor 0
    T->NIL->chave = 0; 
// Inicializa com valor NULL
    T->NIL->esquerda = NULL;
// Inicializa com valor NULL
    T->NIL->direita = NULL;
// Inicializa com valor NULL
    T->NIL->pai = NULL;
// Como a raiz ainda não aponta para nada vai apontar para o T->NIL ao inves de NULL
    T->raiz = T->NIL;
    return T;
}

// Função para realizar o rebalanceamento da arvore quando pesa muito para a direita
void rotacao_esquerda(ArvoreRubroNegra *T, No *x) {
// y adota o filho x->direita
    No *y = x->direita;
// x->direita adota o filho y->esquerda 
    x->direita = y->esquerda;

    if (y->esquerda != T->NIL) {
// Garante que o no y->esquerda que foi adotado por x vai entender que x agora é seu pai
// por isso y->esquerda->pai = x está dizendo que x agora é pai de y->esquerda
        y->esquerda->pai = x;
    }
    
// A ligação que o pai de x tinha com x agora é refeita para y ou seja
// se x era a raiz da arvore agora y é a raiz
    y->pai = x->pai;
    if (x->pai == T->NIL) {
        T->raiz = y;
    } else if (x == x->pai->esquerda) {
        x->pai->esquerda = y;
    } else {
        x->pai->direita = y;
    }
    
// Agora x se torna o filho esquerdo de y
    y->esquerda = x;
    x->pai = y;
}

// Função para realizar o rebalanceamento da arvore quando pesa muito para a esquerda
void rotacao_direita(ArvoreRubroNegra *T, No *y) {
// x adota o filho y->esquerda
    No *x = y->esquerda;
// y->esquerda adota o filho x->direita
    y->esquerda = x->direita;

    if (x->direita != T->NIL) {
// Garante que o no x->direita que foi adotado por y vai entender que y agora é seu pai
// por isso x->direta->pai = y está dizendo que y agora é pai de x->direita
        x->direita->pai = y;
    }

// A ligação que o pai de y tinha com y agora é refeita para x ou seja
// se y era a raiz da arvore agora x é a raiz
    x->pai = y->pai;
    if (y->pai == T->NIL) {
        T->raiz = x;
    } else if (y == y->pai->direita) {
        y->pai->direita = x;
    } else {
        y->pai->esquerda = x;
    }
    
// Agora y se torna o filho direito de x
    x->direita = y;
    y->pai = x;
}

// Função para buscar um valor na Arvore    Rubro   Negra
No* buscar(ArvoreRubroNegra *T, int chave) {
    No *atual = T->raiz;
// A função realiza a busca pelo valor desejado
// Se o valor for menor que a raiz ele vai para a esquerda
// Se for maior vai para a direita e retorna o ponteiro diferente de T->NIL
// Caso não encontre irá retorna T->NIL
    while (atual != T->NIL && chave != atual->chave) {
        if (chave < atual->chave) {
            atual = atual->esquerda;
        } else {
            atual = atual->direita;
        }
    }
    return atual;
}

// Função auxiliar para garantir que apos a inserção
// a Arvore Rubro Negra continuara balanceada
void inserir_fixup(ArvoreRubroNegra *T, No *z) {
// Como não pode ter VERMELHO com VERMELHO o while se basea no pai ser VERMELHO
    while (z->pai->cor == VERMELHO) {

// Esse if faz a seguinte pergunta o pai do meu nó z é o filho esquerdo do meu avó z
// Verficando se o caso VERMELHO com VERMELHO acontece
        if (z->pai == z->pai->pai->esquerda) {

// Logicamente se a esquerda é o pai a direita é o tio sendo nele que baseamos a troca de cor
            No *y = z->pai->pai->direita;
            
// Se o tio for vermelho fazemos a troca
            if (y->cor == VERMELHO) {
                
// z->pai->cor e y->cor onde y->cor é o tio mudam para PRETO
// e o nó avo z->pai->pai->cor vira VERMELHO
                z->pai->cor = PRETO;
                y->cor = PRETO;
                z->pai->pai->cor = VERMELHO;
// Essa parte é muito importante pois e se o bisavo for VERMELHO
// por isso z = z->pai->pai pois se o caso for verdadeiro o loop continua
                z = z->pai->pai;
            }

// INSERIR AQUI CODIGO QUE FALTA(INTERROMPIDO)------------------------------------------------------------------------------------------------------------



//FUNÇÃO INSERÇÃO ABAIXO.
void inserir(ArvoreRubroNegra*T, int chave ){
  No z = (No)malloc(sizeof(No)); //No auxiliar + alocação de memoria + atriubição de valor ao No.
  z->chave = chave;

  //DOIS PONTEIROS DE BUSCA.
  No *y = T->NIL;
  No *x = T->raiz;

  //LOOP PARA ENCONTRAR FOLHA VAZIA
  while (x!= T->NIL){
    y = x; //o Y serve para o último lugar o último do  nó caso o X seja NIL.

//IF utilizado para mover o NO caso o valor for menor para esquerda ou maior para a direita.
    if(z->chave<x->chave){
      x = x->esquerda;
    }else{
      x = x->direita;
    }
  }
z-> pai = y;
if (y == T->NIL){
  T->raiz = z;
}// Usado caso o y esteja vazio a árvore também estará vazia, então o valor de y se tornará a raiz da árvore.
else if (z->chave < y->chave){
  y->esquerda = z;
}else {
  y->direita = z;
}
z->esquerda = T->NIL;
z->direita = T->NIL;
z->cor = VERMELHO;

inserir_fixup(T,z);
}


int main() {
    int opc = 0, valor;
    ArvoreRubroNegra *T = criar_arvore();
    No* resultado;

    do{
        printf("Escolha uma opcao abaixo.\n(0) Finalizar o programa.\n(1) Inserir um valor.\n(2) Remover um valor.\n");
        printf("(3) Procurar um valor.\n(4) Imprimir a Arvore Rubro Negra.\n");
        scanf("%d", &opc);
        
        switch(opc){
            
            case 0:
                printf("Programa Encerrado.\n");
                break;
                
            case 1:
                printf("Digite o valor que deseja inserir.\n");
                scanf("%d", &valor);
                inserir(T,valor);
                printf("Valor: %d inserido com sucesso.\n",valor);
            break;
            
            case 2:
                printf("Digite o valor que deseja remover.\n");
                scanf("%d",&valor);
                remover(T,valor);
                printf("Valor: %d removido com sucesso.\n", valor);
            break;
            
            case 3:
                printf("Digite o valor a ser buscado.\n");
                scanf("%d",&valor);
                resultado = buscar(T,valor);
                if (resultado != T->NIL) {
                    printf("Valor %d encontrada! Cor: %s\n", valor, resultado->cor == VERMELHO ? "Vermelho" : "Preto");
                }
                else {
                    printf("Valor %d não encontrada.\n", valor);
                }
            break;
            
            case 4:
                em_ordem(T, T->raiz);
                printf("\n");
            break;
            
            default:
                printf("Opcao não conhecida.\nTente Novamente.\n");
                break;
        }
        
    }while(opc != 0);
    
    return 0;
}
